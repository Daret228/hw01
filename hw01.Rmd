---
title: "hw01"
author: "БорисихинЛев_РИ-411055"
date: "2024-10-17"
---

Загрузим данные в датафрейм с использованием функции `read.table()`

```{r}
data.df <- read.table("https://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
cat("Число строк: ", ncol(data.df))
cat("\nЧисло столбцов: ", nrow(data.df))
```

Получим названия колонок с помощью `colnames()`

```{r}
colnames(data.df)
```

Извлечем элемент, находящийся в 5-й строке и 7-м столбце

```{r}
data.df[5, 7]
```

Выведем вторую строку датафрейма

```{r}
data.df[2, ]
```

Присвоим имена столбцам датафрейма: первые три столбца — это `year`, `month` и `day`, остальные столбцы — от 0 до 23

```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
```

Используем функции `head()` и `tail()` для просмотра первых и последних 6 строк. Столбцы с 0 по 23 отображают осадки по часам.

```{r}
head(data.df)
tail(data.df)
```

```{r}
data.df$daily <- rowSums(data.df[, 4:27])
head(data.df)
hist(data.df$daily, main = "Осадки по дням", xlab = "Осадки", ylab = "Число дней", col='blue')
```
В данных есть некорректные значения (-999), исправим это.

```{r}
fixed.df <- data.df[data.df$daily > 0, ]
hist(fixed.df$daily, main = "Осадки по дням", xlab = "Осадки", ylab = "Число дней", breaks = 80, col='green')
```
Новый датафрейм исключает отрицательные значения и дни без осадков. Новая гистограмма более точна, так как построена по валидным данным.

Создадим массив строк

```{r}
v <- c("4", "8", "15", "16", "23", "42")
```

Найдем максимальное значение в массиве строк (результат зависит от кодировки и локали)

```{r}
max(v)
```

Отсортируем массив строк (результат также зависит от кодировки и локали)

```{r}
sort(v)
```

Следующая команда приведет к ошибке, так как нельзя складывать строки

```{r}        
sum(v)
```

Создадим вектор, содержащий строки и числа. В первом случае всё корректно, во втором — ошибка, так как попытка обратиться к индексу числа является некорректной.

```{r}   
v2 <- c("5",7,12)
```

```{r}
v2[2] + 2[3]
```

Создадим датафрейм с колонками `z1`, `z2`, `z3`, присвоим им значения "5", 7, 12 соответственно и сложим элементы 2 и 3 столбцов первой строки.

```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

Создадим список с элементами `z1`, `z2`, `z3`, `z4` и сложим 2-й и 4-й элементы. В последней команде ошибка, так как `l4[2]` возвращает не значение элемента, а подсписок вида `list(z2=42)`.

```{r}        
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]
```

Создадим последовательность чисел от 1 до 10000 с шагом 372 с помощью функции `seq()`

```{r}
seq(from = 1, to = 10000, by = 372)
```

Создадим последовательность из 50 чисел от 1 до 10000 с использованием параметра `length.out`, который распределяет значения равномерно.

```{r}
seq(from=1, to=10000, length.out=50)
```

Разница между командами в том, что первая повторяет всю последовательность трижды, а вторая — каждый элемент трижды перед переходом к следующему.

```{r}
rep(1:5,times=3)
rep(1:5, each=3)
```